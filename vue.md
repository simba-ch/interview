# Vue篇
## Vue 3 中的 Composition API 和 Options API 有什么区别？分别适用于哪些场景？
| 特性               | composition API                          | options API                            |
| ------------------ | ---------------------------------------- | -------------------------------------- |
| 逻辑组织方式       | 通过setup函数                            | 通过选项                               |
| 代码可读性         | 复杂组件更清晰，逻辑聚合便于维护         | 简单组件更直观，可读性更强             |
| 对typescript的支持 | 对typescript支持更好                     | 对typescript的支持较差                 |
| 可复用性           | 易于创建重复用逻辑                       | 需要通过mixnis或高阶组件               |
| 学习曲线           | 对新手学习曲线较陡峭，需要理解更多概念   | 比较适合新手，符合传统的对象式编程思维 |
| 灵活性             | 更灵活，可以直接操作响应式数据和生命周期 | 提供固定结构，灵活性较低               |


## Composable Functions 
特点：复用，解耦，独立测试
- 逻辑复用：可以将组件中的通用逻辑抽取出来，避免重复代码。
- 独立性强：Composable 函数与组件解耦，可以单独测试和复用。
- 灵活性：可灵活组合多个 Composable 函数，实现复杂逻辑。
- 响应式：内置对 Vue 的响应式数据支持，直接使用 ref、reactive 等。


结构：
- 输入参数：通过参数传入动态配置。
- 响应式状态：定义并返回响应式数据。
- 逻辑处理：包含业务逻辑或功能。
- 生命周期钩子：在必要时使用 Vue 的生命周期函数。


## 请解释 Vue 3 的响应式原理，它与 Vue 2 的实现有什么不同？
| 特性       | Vue3(Proxy)                                     | Vue 2（Object.defineProperty）                      |
| ---------- | ----------------------------------------------- | --------------------------------------------------- |
| 底层机制   | 基于Proxy拦截对象的所有操作                     | 基于object.defineProperty拦截对象的属性的访问和修改 |
| 响应式范围 | 深度拦截对象的所有操作，包括 增删改查和原型继承 | 仅对初始化的属性响应式，新增和删除属性需要手动处理  |
| 性能       | 不需要递归对象，初始化性能好                    | 初始化递归劫持，性能受限于数据规模                  |
| 数组支持   | 原生支持数组，无需特殊处理                      | 通过重写数组方法实现响应式                          |
| 灵活性     | 支持更复杂的响应式逻辑（Map,Set）               | 仅支持普通对象和数组                                |

## Vue 3 中如何使用 Teleport，它的典型使用场景是什么？
teleport一般用于一些全局UI组件：
全局加载动画
工具提示框
模态框
全局通知
弹出消息

当 Teleport 的目标节点不存在时，Vue 会发出警告，内容会保留在原始位置。为了避免这种情况：
- 确保目标节点在 DOM 中存在（通过模板或动态创建）。
- 使用条件渲染或动态绑定 to 属性处理动态目标。
- 对于全局目标，建议使用工具或插件统一初始化。

## v-model 在 Vue 3 中有什么变化？如何实现双向绑定？
- 默认绑定的是modelValue,事件是update:modelValue
- 支持多个v-model,每个绑定可以设置不同的prop和事件
- 移除了v-bind.async,推荐使用v-model的新特性代替


### 双向绑定的实现原理：
1. 父组件通过v-model将数据传递给子组件的modelValue prop
2. 子组件通过监听用户输入，调用 $emit('update:modelValue',newValue) 通知父组件更新绑定数据
3. 父组件捕获事件后，自动更新对应数据


### watch、watchEffect、watchPostEffect三者对比
| 特性     | watch                       | watchEffect                      | watchPostEffect          |
| -------- | --------------------------- | -------------------------------- | ------------------------ |
| 依赖收集 | 手动                        | 自动                             | 自动                     |
| 首次执行 | 默认不执行，需配置immediate | 默认立即执行                     | 默认立即执行             |
| 触发时机 | 数据变化后                  | 数据变化后（视图更新前）         | 数据变化后（视图更新后） |
| 适用场景 | 精确监听特定数据的变化      | 简单依赖追踪，快速实现响应式逻辑 | 需要依赖最新的DOM更新    |


### vue指令
v-text v-html v-show v-if v-else-if v-else v-on v-bind v-memo v-model v-slot v-cloak


## 实践问题

## 假设你在一个 Vue 3 项目中需要实现一个全局状态管理系统，但不能使用 Vuex 或 Pinia，你会如何设计？


## 如何在 Vue 3 中使用异步组件？它的优势是什么？

## 你如何在 Vue 3 中优化大型组件的性能？能举一个具体的例子吗？

## 有一个需求，需要在子组件中动态添加多个表单，并在父组件中统一收集这些表单数据，你会如何设计组件的通信？

## 场景问题

## 项目上线后发现某些功能在旧版浏览器（比如 IE 11）上不能正常工作，你会怎么解决这个问题？


## 团队里有同事对 Vue 3 不太熟悉，你会如何帮助他们快速上手？


## 开放性问题

## 你在实际项目中遇到过什么困难？是如何用 Vue 解决的？


## 与其他前端框架相比，你觉得 Vue 的优势和不足是什么？


## 谈谈你对 Vue 未来发展的看法，比如 Vue 3.3 之后可能会有哪些值得期待的功能？
